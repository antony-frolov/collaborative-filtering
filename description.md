# Отчет по заданию «MapReduce. Коллаборативная фильтрация»

## Входные данные

Входными данными для данной задачи являются два файла:

- `ratings.csv`, в котором записаны тройки $(u_k, f_i, r_{ki})$, где $r_i$ — оценка от 1 до 5, которую пользователь $u_k$ дал к фильму $f_i$

- `movies.csv`, в котором записаны ID фильмов и их названия

## Описание MapReduce задач

### 1. Агрегация оценок по пользователям и подсчет отклонений оценок от среднего

На первом этапе для каждого пользователя $u_k$ мы хотим получить список пар из фильма $f_i$ и отклонения оценки $r_{ki}$ от ее среднего значения для этого пользователя.

Для этого на map фазе оценки агрегируются по пользователям, а затем на reduce фазе подсчитываются средние значения полученных наборов оценок, которые затем вычитаются из каждой оценки в наборе.

Mapper:

- Вход: `user, movie, rating, timestamp` из файла `ratings.csv`

- Выход: `user - (movie, rating)`

- Сложность:

  - По времени: $O(1)$
  
  - По памяти: $O(1)$

Reducer:

- Вход: `user - [ (movie, rating), ... ]`

- Выход: `user - movie_diff_list`,

    где `movie_diff_list =  [ (movie, diff), ... ]`

- Сложность:

  - По времени: $O(\alpha I)$
  
  - По памяти: $O(\alpha I)$

### 2. Подсчет похожести фильмов

На 2 этапе мы хотим для каждой пары фильмов $(f_i, f_j)$ посчитать их похожесть $\operatorname{sim}(i, j)$ по следующей формуле:
$$
\operatorname{sim}(i, j) = \frac{\sum\limits_{u \in U_{i,j}} \left( r_{u,i} - \overline{r_{u}} \right) \left( r_{u,j} - \overline{r_{u}} \right)}{\sqrt{\sum\limits_{u \in U_{i,j}} \left( r_{u,i} - \overline{r_{u}}\right)^2} \sqrt{\sum\limits_{u \in U_{i,j}} \left(r_{u,j} - \overline{r_u}\right)^2}}
$$

Для этого на map фазе для каждого пользователя по списку пар фильм–отклонение, полученного на предыдущей фазе, на reduce фазу передаются все комбинации из 2 различных пар.

Затем на reduce фазе вход агрегируется по парам фильмов,  сортируется по пользователям и по полученному списку выполняется подсчет похожестей. При этом пары фильмов с $sim(f_i, f_j) \le 0$ не включаются в вывод (они не будут вносить вклад в предсказание рейтинга непросмотренных фильмов). Похожести подсчитываются только для тех пар фильмов, для которых есть хотя бы один пользователь, просмотревший оба фильма, поэтому деление на 0 исключено (пары фильмов, для которых такого пользователя нет, не влияют на предсказания).

Mapper:

- Вход: `user - movie_diff_list` с фазы 1

- Выход:

    ```python
    for (movie1, diff1), (movie2, diff2) in combinations(movie_diff_list, 2):
        emit (movie1, movie2) - (user, diff1, diff2)
    ```

- Сложность:

  - По времени: $O\big( (\alpha I)^2 \big) = O(\alpha^2 I^2)$

  - По памяти: $O(\alpha I)$

Reducer:

- Вход: `(movie1, movie2) - [ (user, diff1, diff2), ... ] sorted by user`

- Выход: `(movie1, movie2) - sim`

- Сложность:
  
  - По времени: $O(\alpha^2 U)$

  - По памяти: $O(\alpha^2 U)$

### 3. Подготовка к подсчету рейтингов

На данном этапе мы хотим для каждой пары $(u_k, f_i)$ получить все оценки, которые пользователь $u_k$ оставлял  фильмам $f_j$ из множества $I_{u_k}$ просмотренных пользователем $u_k$ фильмов, а также похожести $\operatorname{sim}(i, j), \ j \in I_{u_k}$ этих фильмов на фильм $f_i$.

Для этого мы агрегируем пары фильмов и их похожести с предыдущей фазы по первому фильму $(f_j)$ в паре, а тройки $(u_k, f_j, r_{kj})$,  из файла `ratings.csv` по оцененному фильму $(f_j)$.

Таким образом для каждого фильма $f_j$ мы получаем список фильмов $f_i$ и их похожестей на фильм $f_j$, и список пользователей $u_k$ и оценок $r_{kj}$, поставленных ими фильму $f_j$. Для каждого фильма $f_j$ мы выдаем декартово произведение полученных списков. Также в вывод для каждого фильма $f_j$ добавляются записи содержащие фильм $f_j$ и просмотревших его пользователей для фильтрации просмотренных фильмов на следующей фазе.

$f_i$ = `movie_comp`, $f_j$ = `movie_rated`

Mapper:

- Вход:

    1. `(movie1, movie2) - sim` с фазы 2

    2. `user, movie, rating, timestamp` из файла `ratings.csv`

- Выход:

    1. `(movie_rated) - (movie_tag, movie_comp, sim)`

    2. `(movie_rated) - (user_tag, user, rating)`

    `movie_rated = movie1 = movie`

    `movie_comp = movie2`

- Сложность:
  
  - По времени: $O(1)$

  - По памяти: $O(1)$

Reducer:

- Вход: `movie_rated - [ (tag, movie_comp/user, sim/rating), ... ] sorted by tag`

    на самом деле мы получаем два списка один за другим:

    `movie_sim_list = [ (movie_tag, movie_comp, sim), ... ]` и

    `user_rating_list = [ (user_tag, user, rating), ... ]`

- Выход:

    ```python
    for (movie_comp, sim), (user, rating) in product(movie_sim_list, user_rating_list):
    emit (user, movie_comp) - (movie_rated, sim, rating)
    ```

- Сложность:
  
  - По времени: $O(I \cdot \alpha I) = O(\alpha I^2)$

  - По памяти: $O(I) + O(\alpha I) = O(I)$

### 4. Подсчет рейтингов для непросмотренных фильмов

На 4 фазе мы для каждого пользователя предсказываем рейтинги непросмотренных им фильмов по следующей формуле:
$$
\hat r_{u,i} = \frac{\sum\limits_{j \in I_u} \operatorname{sim}(i, j) r_{u,j}}{\sum\limits_{j \in I_u} \operatorname{sim}(i, j)}
$$

Для этого мы на map фазе агрегируем полученные на вход записи по пользователю и предсказываемому фильму, а на reduce фазе производим расчеты. Те пары пользователь-фильм, для которых в полученном списке есть фильм, совпадающий с предсказываемым, игнорируются и не включаются в вывод (это означает, что данный фильм пользователь уже просмотрел).

Mapper (тождественный):

- Вход: `(user, movie_comp) - (movie_rated, sim, rating)` c фазы 3

- Выход: `(user, movie_comp) - (movie_rated, sim, rating)`

- Сложность:

  - По времени: $O(1)$

  - По памяти: $O(1)$

Reducer:

- Вход: `(user, movie_comp) - [ (movie_rated, sim, rating), ... ]`

- Выход: `(user, movie_comp) - rating`

- Сложность:
  
  - По времени: $O(\alpha I)$

  - По памяти: $O(\alpha I)$

### 5. Замена ID фильма на его название

На 5 фазе мы добавляем к каждой входной записи название фильма.

Для этого на map фазе мы агрегируем полученные с 4 фазы записи по предсказываемому фильму, а записи из файла `movies.csv` по названию фильма.

На reduce фазе мы добавляем к каждому фильму его название и выводим те же записи, что получили с 4 фазы.

Mapper:

- Вход:

    1. `(user, movie) - rating` с фазы 4

    2. `movie, title, genres` из файла `movies.csv`

- Выход:

    1. `(movie, rating_tag) - (user, rating)`

    2. `(movie, title_tag) - title`

- Сложность:

  - По времени: $O(1)$

  - По памяти: $O(1)$

Reducer:

- Вход: `(movie) - [ (tag, (user, rating)/title), ... ] sorted by tag`

    На самом деле мы получаем название фильма и список рейтингов, предсказанных для этого фильма.

- Выход: `user - (rating, movie, title)`

- Сложность:
  
  - По времени: $O \big( (1 - \alpha) U \big)$

  - По памяти: $O(1)$

### 6. Отбор топ 100 фильмов и форматирование вывода

На последней фазе для каждого пользователя мы отбираем топ 100 фильмов с самым высоким предсказанным рейтингом.

Для этого мы агрегируем полученный с предыдущей фазы вход по пользователю и сортируем его по рейтингу в порядке убывания. Затем мы отбираем первые 100 записей в полученном списке, форматируем их и выводим.

Mapper (тождественный):

- Вход: `user - (rating, movie, title)` c фазы 5

- Выход: `user - (rating, movie, title)`

- Сложность:

  - По времени: $O(1)$

  - По памяти: $O(1)$

Reducer:

- Вход: `user - [ (rating, movie, title), ... ] sorted by rating`

- Выход: `<user>@<rating>%<title>@ ... @<rating>%<title>`

- Сложность:
  
  - По времени: $O \big( (1 - \alpha) I \big)$

  - По памяти: $O(1)$

## Время работы

Выполнение всех фаз получилось заняло около 20 минут. При этом дольше всего выполняется 4 фаза, так как ей на вход подается больше всего данных и на их сортировку и расчеты по ним уходит много времени.
